#!/usr/bin/env sh

# interactive cd with arrow keys - think "fast travel"
# implemented in posix shell, with as little usage of external processes as possible
# assumes terminal is vt100

# global state
# index of current item in PWD/*
i=1
# current item in PWD/* "i string", used for a faster right arrow (cd into i). precomputed during paint new state.
is=
# number of items, used for i wrapping around up/down. precomputed during paint new state.
n=

handle () {
    # clear the terminal - POSIX specifies `tput clear`
    # there is the vt100 assumption, but printf '\x1bc' (RIS - reset terminal to initial state)
    # results in cursor visual artifacting while moving it around at the end of handle()
    tput clear

    # handle key, and adjust index and/or pwd as necessary
    # ABCD corresponds to the vt100 special key codes for arrow keys

    # still unsure why this works, dd ibs=1 count=1 should only give 1 byte under stty raw (which sets cs8 - character size 8)
    # while arrow keys will send 3 bytes/chars - escape, open bracket, capital letter
    # the subshell and assign to variable might be doing some weird stuff, because if i dd ... | read key, it breaks, and key isn't easily introspectable
    case "$1" in
        A|k)
            # up
            i=$((i-1))
            [ "$i" = 0 ] && i="$n"
            ;;
        B|j)
            # down
            if [ "$i" = "$n" ]; then
                i=1
            else
                i=$((i+1))
            fi
            ;;
        C|l)
            # right
            if [ -d "$is" ]; then
                cd "$is"
                i=1
            fi
            ;;
        D|h)
            # left - go up a directory, and recalculate the index.
            wd="${PWD##*/}"
            cd ..
            i=1
            for item in "$PWD"/*; do
                [ "${item##*/}" = "$wd" ] && break
                i=$((i+1))
            done
            ;;
        q)
            exit
            ;;
    esac

    # store PWD for icd-wrapper to cd into.
    printf %s "$PWD" > /tmp/icd-dir

    # paint new state
    # TODO: scrolling items past # lines available
    printf "\x1b[1m%s\x1b[0m\n\n" "$PWD"
    j=1
    for item in "$PWD"/*; do
        disp="${item##*/}"
        if [ "$i" = "$j" ]; then
            disp="> ${disp}"
            is="$item"
        fi
        if [ -d "$item" ]; then
            printf "%s/\n" "$disp"
        else
            printf %s\\n "$disp"
        fi
        j=$((j+1))
    done
    n=$((j-1))

    # move cursor to upper left corner, then move down i+1 lines
    _i=$((i+1))
    printf "\x1b[H\x1b[%sB" "$_i"
}

main () {
    # XXX: user can't interactively send SIGINT via ^C due to stty raw mode for capturing the key
    trap "exit" INT TERM HUP QUIT
    trap 'handle ""' WINCH

    # populate initial global state, clear the screen and initial painting
    handle ""
    while :; do
        stty raw
        # XXX: see note in handle() case statement
        key="$(dd ibs=1 count=1 2>/dev/null)"
        stty -raw
        handle "$key"
    done
}

main
